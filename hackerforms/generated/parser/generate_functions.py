
###############################################################################
##             This file is generated by hackerforms-protocol.               ##
##        Do not change this file. Any changes will be overwritten.          ##
###############################################################################
from jinja2 import Template
import inspect

from .. import input_types
from .. import output_types
from ..input_types import *
from ..output_types import *
from .templates.read_functions_template import read_functions_template
from .templates.display_functions_template import display_functions_template
from .templates.page_template import page_template
from .helpers import get_default_key, get_method_signature, get_function_name, get_widget_types
from .docs_parser import group_docs_by_section, generate_page_method_docs


def inspect_widget_type(widget_type):
    '''This function return ans object with __init__ constructor signature as dict, its docs as string and convert_answer method's docs'''

    widget = {}
    _class = widget_type[1]
    for method in inspect.getmembers(_class):
        if '__init__' in method[0]:
            widget['signature'] = inspect_init_signature(method)
            widget['docs'] = group_docs_by_section(inspect_init_docs(method))
        if 'convert_answer' in method[0]:
            widget['return_docs'] = inspect_answer_docs(method)
    return widget


def inspect_init_signature(method):
    for property in inspect.getmembers(method[1]):
        if '__annotations__' in property[0]:
            return get_method_signature(property[1])


def inspect_init_docs(method):
    for property in inspect.getmembers(method[1]):
        if '__doc__' in property[0]:
            return property[1]


def inspect_answer_docs(method):
    for property in inspect.getmembers(method[1]):
        if '__doc__' in property[0]:
            return property[1]


def extract_widgets_methods(types, postfix='Input'):
    widgets = {}

    classes = inspect.getmembers(types, inspect.isclass)
    widget_types = get_widget_types(classes, postfix)

    for widget_type in widget_types:
        widgets[widget_type[0]] = inspect_widget_type(widget_type)
    for widget, widget_obj in widgets.items():
        signature_str = ""
        page_input = ""

        if postfix == 'Input':
            widgets[widget]['default_key'] = get_default_key(
                get_method_signature(widget_obj['signature']))

        for key, type in widget_obj['signature'].items():
            if key != 'key':
                signature_str += f"{key}: {type}, "
                page_input += f"{key}, "

        signature_str += "**kwargs"
        page_input += "**kwargs"
        widgets[widget]['signature_params'] = signature_str
        widgets[widget]['page_input'] = page_input
        widgets[widget]['func_name'] = get_function_name(
            widget, postfix=postfix)

        if widgets[widget]['docs'] and postfix == 'Input':
            widgets[widget]['page_docs'] = generate_page_method_docs(
                widgets[widget]['docs'], widgets[widget]['default_key'])
        elif widgets[widget]['docs'] and postfix == 'Output':
            widgets[widget]['page_docs'] = generate_page_method_docs(
                widgets[widget]['docs'], widget_type='output')

        elif not 'docs' in widgets[widget]:
            raise Exception(
                f"{widget} does not contain docs. Please, insert its documentation in __init__ method of widget type class.")

    return widgets


def generate_input():
    input_widgets = extract_widgets_methods(input_types)
    input_functions = Template(
        read_functions_template).render(widgets=input_widgets)
    save('inputs', input_functions)


def generate_output():
    output_widgets = extract_widgets_methods(output_types, postfix='Output')
    output_functions = Template(
        display_functions_template).render(widgets=output_widgets)
    save('outputs', output_functions)


def generate_page():
    input_widgets = extract_widgets_methods(input_types)
    output_widgets = extract_widgets_methods(output_types, postfix='Output')
    page = Template(page_template).render(
        input_widgets=input_widgets, output_widgets=output_widgets)
    save('page', page)


def save(name, file):
    f = open(f'src/library/generated/{name}.py', 'w')
    f.write(file)
    f.close()
